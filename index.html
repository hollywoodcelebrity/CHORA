<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub Codespaces Flow</title>
    
<script src="https://cdn.tailwindcss.com"></script>
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        /* Custom styles override Tailwind to ensure full black background and canvas cover */
        body {
            background-color: #000;
            overflow: hidden;
            margin: 0;
            cursor: default;
            font-family: 'Inter', sans-serif;
        }

        #container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none; /* Prevents default mobile behaviors like scrolling */
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allows mouse events to pass through to the canvas */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center; /* Keeps the bottom footer centered */
            padding: 2rem;
            color: white;
            z-index: 10;
        }

        /* 2D canvas for text sampling - must be hidden */
        #text-canvas {
            display: none;
        }

        .instructions-box {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 12px;
            text-shadow: 0 0 5px rgba(139, 92, 246, 0.5);
        }

        /* NEW STYLE: Spinner is white */
        .loading-spinner-white {
            color: #ffffff;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    
<div id="container"></div>

    
<canvas id="text-canvas"></canvas>

    
<div id="ui-overlay">
        
<div class="w-full flex justify-start">
            <div class="instructions-box flex flex-col items-start">
                
<p class="text-sm text-gray-200">
                    Click & Drag to rotate the flow. Single Click to generate a word.
                </p>
                
                
<p id="audio-status" class="text-xs text-gray-400 pt-1">Audio: Off (Click to Enable)</p>

                
<div id="loading-indicator" class="hidden w-full flex justify-start pt-2">
                    <svg class="h-5 w-5 loading-spinner-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                </div>
            </div>
        </div>
        
        
<div></div>

        
<div class="text-xs text-gray-500">
            Powered by Three.js & Gemini API
        </div>
    </div>

    <script>
        // Global variables for Firebase auth (Required for Canvas environment)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        // --- Tone.js Music Variables ---
        let isMusicPlaying = false; 
        let ambientSynth, reverb, delay, musicLoop;
        
        // Define three different subtle ambient chord progressions
        const CHORD_MOODS = [
            // 1. Tender (Minor key, mellow)
            [ ["C3", "Eb3", "G3", "Bb3"], ["F3", "Ab3", "C4", "Eb4"], ["Bb2", "D3", "F3", "A3"], ["Eb3", "G3", "Bb3", "D4"] ], 
            // 2. Lonely (Slightly darker, more suspended feel)
            [ ["D3", "F3", "A3", "C4"], ["G3", "Bb3", "D4", "F4"], ["C3", "E3", "G3", "B3"], ["F3", "A3", "C4", "E4"] ],
            // 3. Deep/Structural (Tension/Release)
            [ ["G2", "Bb2", "D3", "F3"], ["C3", "E3", "G3", "Bb3"], ["F3", "A3", "C4", "Eb4"], ["Bb2", "D3", "F3", "Ab3"] ]
        ];
        let currentMoodIndex = 0; // Starts with the Tender mood

        // --- Three.js Variables ---
        let scene, camera, renderer;
        let particles, geometry, material;
        let positions, originalPositions, targetPositions, wordStartPositions;
        let particleData = []; // Stores base properties (radius, angle, phase) for organic motion
        const PARTICLE_COUNT = 25000; 
        const VORTEX_HEIGHT = 150; 
        const VORTEX_OFFSET_Y = -10; // ADJUSTED: Moved up to -10
        const VORTEX_RADIUS_MAX = 15; 
        const VORTEX_SPEED = 0.15; 
        const MIN_RADIUS_FACTOR = 0.3; // Not used, but kept for context
        
        // Spin speeds
        const VORTEX_SPIN_SPEED = 0.05; 
        const WORD_SPIN_SPEED = 0.3;    
        // Fixed canvas width for normalization
        const TARGET_CANVAS_WIDTH = 600; 
        
        // Camera Zoom Constraints
        const MIN_CAMERA_Z = 30; 
        const MAX_CAMERA_Z = 200; 
        const ZOOM_SPEED = 5; 

        // --- AI Caching and State ---
        let wordCache = []; 
        let wordGenerationCount = 0; 
        let usedWordsSet = new Set(); // Stores all previously used words
        
        // --- Interaction & State Variables ---
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let rotationTarget = new THREE.Vector3(0, 0, 0);
        let rotationSpeed = 0.005;

        let interactionState = 'vortex'; // 'vortex' or 'word' or 'returning' or 'loading'
        let wordDisplayTime = 0;
        const WORD_DISPLAY_DURATION = 8000; // 8 seconds
        const WORD_TRANSITION_MS = 3000; 

        // --- AI API Configuration (MUST BE CONSTANT) ---
        const apiKey = "AIzaSyDI2wl7P-yDGAaigBp9c5-Q5BHaf1Xpp6E";
        const API_MODEL = "gemini-2.5-flash"; // Corrected to stable model
        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${API_MODEL}:generateContent?key=${apiKey}`;

        // --- Utility Functions ---

        /**
         * Exponential backoff utility for API calls.
         */
        async function withBackoff(fn, retries = 5, delay = 1000) {
            for (let i = 0; i < retries; i++) {
                try {
                    return await fn();
                } catch (error) {
                    console.error(`API attempt ${i + 1} failed:`, error); // Log API attempts
                    if (i === retries - 1) throw error;
                    await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, i)));
                }
            }
        }
        
        // --- Tone.js Music Functions ---
        
        /**
         * Initializes all Tone.js synths and effects.
         */
        function initializeMusic() {
             // 1. Setup Effects (Reverb and Delay for atmosphere)
            reverb = new Tone.Reverb(4).toDestination();
            delay = new Tone.FeedbackDelay("1n", 0.4).connect(reverb);
            
            // 2. Setup Instrument (PolySynth for polyphony to play chords)
            ambientSynth = new Tone.PolySynth(Tone.Synth, {
                // Using a soft Sine oscillator for ambient mood
                oscillator: { type: "sine" },
                envelope: {
                    attack: 4, 
                    decay: 1, 
                    sustain: 0.8, 
                    release: 5 
                },
                volume: 0 
            }).connect(delay); 

            Tone.Transport.bpm.value = 35; // Very slow tempo
        }

        /**
         * Creates and starts the main ambient music loop using the current mood index.
         */
        function setupMusicLoop() {
             if (musicLoop) {
                musicLoop.dispose(); // Stop and dispose of old loop
            }

            const chords = CHORD_MOODS[currentMoodIndex % CHORD_MOODS.length];
            let index = 0;
            
            // Loop runs every 2 measures (2 bars of 4/4 time)
            musicLoop = new Tone.Loop(time => {
                const chord = chords[index % chords.length];
                // PolySynth correctly handles the array of notes ('chord')
                ambientSynth.triggerAttackRelease(chord, "8n", time);
                index++;
            }, "2n").start(0);

            Tone.Transport.start();
        }
        
        /**
         * Starts music on first user interaction.
         */
        function startAmbientMusic() {
            if (isMusicPlaying) return;
            
            // Try to start the audio context on user interaction
            Tone.start().then(() => {
                // Audio context successfully started
                isMusicPlaying = true;
                document.getElementById('audio-status').textContent = 'Audio: On';
                console.log("Tone.js audio context started successfully.");
                
                // Initialize synths and effects only once
                initializeMusic();
                
                // Set up and start the loop with the initial mood
                setupMusicLoop(); 
            }).catch(e => {
                console.error("Tone.js failed to start audio context:", e);
                document.getElementById('audio-status').textContent = 'Audio: Error';
            });
        }

        /**
         * Called on word generation to change the harmonic mood.
         */
        function shiftMusicMood() {
            if (!isMusicPlaying) return; // Only shift if music is already initialized and playing
            currentMoodIndex = (currentMoodIndex + 1) % CHORD_MOODS.length;
            setupMusicLoop(); // Setup new loop with the new mood
            console.log(`Music mood shifted to index: ${currentMoodIndex}`);
        }
        
        // --- Three.js Setup Functions ---

        function init() {
            if (typeof THREE === 'undefined') {
                console.error("THREE.js library is not loaded. Cannot initialize 3D scene.");
                return;
            }

            const container = document.getElementById('container');

            // 1. Scene setup
            scene = new THREE.Scene();
            
            // 2. Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 100; 
            camera.position.y = 0; // Centered camera vertically

            // 3. Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 1);
            container.appendChild(renderer.domElement);

            // 4. Lights
            scene.add(new THREE.AmbientLight(0x404040, 1.5));
            const pointLight = new THREE.PointLight(0xffffff, 1.0);
            pointLight.position.set(0, 100, 100);
            scene.add(pointLight);

            // 5. Create Particles
            createParticles();

            // 6. Event listeners
            window.addEventListener('resize', onWindowResize);
            container.addEventListener('mousedown', onMouseDown);
            container.addEventListener('mouseup', onMouseUp);
            container.addEventListener('mousemove', onMouseMove);
            container.addEventListener('click', onClick);
            container.addEventListener('wheel', onMouseWheel); 
            
            // Start the animation loop
            animate();
        }

        /**
         * Handles mouse wheel scrolling for zooming in and out.
         */
        function onMouseWheel(event) {
            // Prevent the default scroll behavior on the page
            event.preventDefault();

            // Adjust camera position Z based on scroll delta.
            const delta = event.deltaY * 0.1 * ZOOM_SPEED;

            camera.position.z += delta;

            // Apply zoom constraints
            camera.position.z = Math.max(MIN_CAMERA_Z, Math.min(MAX_CAMERA_Z, camera.position.z));
        }

        /**
         * Calculates the desired elliptical radius at a given yRatio (0 at bottom, 1 at top).
         */
        function getTeardropRadius(yRatio) {
            // FORCED CYLINDER: Returns a constant radius factor of 1.0, 
            // ensuring the width is VORTEX_RADIUS_MAX at all heights.
            return 1.0; 
        }


        function createParticles() {
            geometry = new THREE.BufferGeometry();
            positions = new Float32Array(PARTICLE_COUNT * 3);
            originalPositions = new Float32Array(PARTICLE_COUNT * 3); // Flow target
            targetPositions = new Float32Array(PARTICLE_COUNT * 3); // Word target
            wordStartPositions = new Float32Array(PARTICLE_COUNT * 3); // Temp LERP start point

            const color = new THREE.Color(0xffffff);
            const colors = new Float32Array(PARTICLE_COUNT * 3);
            
            particleData = []; 

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // Initialize particle in the vortex
                const y = (Math.random() * VORTEX_HEIGHT - (VORTEX_HEIGHT / 2)) + VORTEX_OFFSET_Y;
                
                // Calculate max radius based on ELLIPTICAL shape
                // We need to normalize y back to the original VORTEX_HEIGHT space (0 to 1) for the math
                const normalizedY = y - VORTEX_OFFSET_Y;
                const yRatio = (normalizedY + VORTEX_HEIGHT / 2) / VORTEX_HEIGHT; 
                const maxR = VORTEX_RADIUS_MAX * getTeardropRadius(yRatio);

                // --- KEY FIX: BIAS RANDOMNESS TOWARDS LARGER RADII ---
                const r = Math.pow(Math.random(), 0.5) * maxR; 
                
                const theta = Math.random() * Math.PI * 2;
                
                particleData.push({
                    baseR: r,
                    baseTheta: theta,
                    phase: Math.random() * Math.PI * 2,
                    currentY: y 
                });

                // Cylindrical to Cartesian coordinates
                const x = r * Math.cos(theta);
                const z = r * Math.sin(theta);

                // Store in buffers
                positions[i * 3 + 0] = originalPositions[i * 3 + 0] = targetPositions[i * 3 + 0] = x;
                positions[i * 3 + 1] = originalPositions[i * 3 + 1] = targetPositions[i * 3 + 1] = y;
                positions[i * 3 + 2] = originalPositions[i * 3 + 2] = targetPositions[i * 3 + 2] = z;

                // Initialize color to full white/bright
                colors[i * 3 + 0] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            material = new THREE.PointsMaterial({
                // Increased size for a better 'bubble' effect
                size: 0.8, 
                vertexColors: true, // IMPORTANT: Enables per-particle color/brightness control
                transparent: true,
                opacity: 1.0, // Set to 1.0 and use vertex color for fading
                blending: THREE.AdditiveBlending, // Makes the particles glow
                sizeAttenuation: true
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // --- Interaction Handlers ---

        function onMouseDown(event) {
            isDragging = true;
            previousMousePosition = { x: event.clientX, y: event.clientY };
            // START MUSIC ON ANY INTERACTION
            if (!isMusicPlaying) {
                 startAmbientMusic();
            }
        }

        function onMouseUp(event) {
            isDragging = false;
        }

        function onMouseMove(event) {
            if (!isDragging) return; 

            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;

            // Rotation is the only thing happening on drag now.

            rotationTarget.y += deltaX * rotationSpeed;
            rotationTarget.x += deltaY * rotationSpeed;

            rotationTarget.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotationTarget.x));

            previousMousePosition = { x: event.clientX, y: event.clientY };
        }

        let isClick = true;
        function onClick(event) {
            if (isClick && interactionState === 'vortex') {
                event.preventDefault();
                
                // START MUSIC ON SINGLE CLICK (Fallback for mousedown)
                if (!isMusicPlaying) {
                    startAmbientMusic();
                }

                // Mood shift happens here on single click (word generation)
                if (isMusicPlaying) {
                    shiftMusicMood();
                }

                generateAndDisplayWord();
            }
        }

        const dragThreshold = 5;
        document.getElementById('container').addEventListener('mousedown', () => { isClick = true; });
        document.getElementById('container').addEventListener('mousemove', (e) => {
            if (isDragging && (Math.abs(e.clientX - previousMousePosition.x) > dragThreshold || Math.abs(e.clientY - previousMousePosition.y) > dragThreshold)) {
                isClick = false;
            }
        });
        document.getElementById('container').addEventListener('mouseup', () => { isDragging = false; });


        // --- Particle Logic (Organic Flow) ---

        /**
         * Calculates the next position for each particle in the continuous vortex flow.
         * @param {number} time The current elapsed time from the Three.js clock.
         */
        function updateFlowDataAndTarget(time) {
            const tempPositions = originalPositions; 
            const colors = geometry.attributes.color.array; // Reference the color array
            
            const wobbleSpeed = 0.8; 
            const wobbleStrength = 0.7;
            const spiralRate = 0.08; 
            const timeScale = 0.5;

            const globalPulse = Math.sin(time * 0.5) * 0.1; 
            const FADE_ZONE_RATIO = 0.25; 

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                const data = particleData[i];

                // 1. Particle flow (Y-movement) - CONTINUOUS
                data.currentY += VORTEX_SPEED * timeScale;
                
                // 2. Wrap/Respawn logic 
                // Check if particle is past the top edge (VORTEX_HEIGHT/2 + OFFSET)
                if (data.currentY > VORTEX_HEIGHT / 2 + VORTEX_OFFSET_Y) {
                    data.currentY = -VORTEX_HEIGHT / 2 + VORTEX_OFFSET_Y; // Respawn at the bottom edge
                    
                    // Calculate max radius based on current y ratio (0 to 1)
                    const normalizedY = data.currentY - VORTEX_OFFSET_Y;
                    const yRatio = (normalizedY + VORTEX_HEIGHT / 2) / VORTEX_HEIGHT;
                    const maxRAtSpawn = VORTEX_RADIUS_MAX * getTeardropRadius(yRatio); // This will be VORTEX_RADIUS_MAX * 1.0
                    
                    // --- KEY FIX: BIAS RANDOMNESS TOWARDS LARGER RADII ---
                    data.baseR = Math.pow(Math.random(), 0.5) * maxRAtSpawn; 
                    
                    data.baseTheta = Math.random() * Math.PI * 2;
                    data.phase = Math.random() * Math.PI * 2;
                }

                // --- Calculate Dynamic X/Z Position and Fading ---
                
                // Normalized Y ratio (0 to 1) relative to the VORTEX_HEIGHT
                const normalizedY = data.currentY - VORTEX_OFFSET_Y;
                const yRatio = (normalizedY + VORTEX_HEIGHT / 2) / VORTEX_HEIGHT; 
                
                let currentMaxR = VORTEX_RADIUS_MAX * getTeardropRadius(yRatio); // This is now always VORTEX_RADIUS_MAX
                
                // --- Fading Logic (Softens the visible boundary) ---
                let alpha = 1.0; 

                // Fade in at the bottom
                if (yRatio < FADE_ZONE_RATIO) {
                    alpha = yRatio / FADE_ZONE_RATIO;
                } 
                // Fade out at the top
                else if (yRatio > 1.0 - FADE_ZONE_RATIO) {
                    alpha = (1.0 - yRatio) / FADE_ZONE_RATIO;
                }
                
                // Clamp alpha between a minimum value (for visibility) and 1.0
                alpha = Math.max(0.01, Math.min(1.0, alpha));

                // Apply alpha factor to the color/brightness
                colors[i3 + 0] = alpha;
                colors[i3 + 1] = alpha;
                colors[i3 + 2] = alpha;
                
                // --- Organic Movement ---
                
                // Jitter/wobble for organic look
                const radiusJitter = (Math.sin(time * 1.5 + data.phase * 0.3) * 0.05) + globalPulse;
                currentMaxR *= (1 + radiusJitter);
                currentMaxR = Math.max(0.001, currentMaxR); // Safety clamp
                
                // Apply organic movement
                const wobble = Math.sin(time * wobbleSpeed + data.phase) * wobbleStrength;
                const currentTheta = data.baseTheta + ((data.currentY - VORTEX_OFFSET_Y) * spiralRate) + wobble;
                
                // Apply radial pulse and scale
                const radialPulse = Math.sin(time * 1.5 + data.phase * 0.5) * 0.1;
                let currentR = data.baseR * (currentMaxR / VORTEX_RADIUS_MAX) * (1 + radialPulse); 
                currentR = Math.min(currentR, currentMaxR);
                
                // e. Convert back to Cartesian
                const x = currentR * Math.cos(currentTheta);
                const z = currentR * Math.sin(currentTheta);

                // Update the TARGET buffer (originalPositions)
                tempPositions[i3 + 0] = x;
                tempPositions[i3 + 1] = data.currentY;
                tempPositions[i3 + 2] = z;
            }
            
            geometry.attributes.color.needsUpdate = true;
        }

        // --- Text Generation & Shaping ---

        async function generateAndDisplayWord() {
            const loadingElement = document.getElementById('loading-indicator');

            // 0. API KEY CHECK (CRITICAL GUARDRAIL)
            if (apiKey === "") {
                console.error("CRITICAL ERROR: API Key is missing. Please insert your Gemini API Key into the 'const apiKey = \"\";' line to enable word generation.");
                return; 
            }
            
            // 1. Fetch or use cached words
            if (wordCache.length === 0) {
                 try {
                    // Show loading indicator
                    loadingElement.classList.remove('hidden');

                    // Temporarily set interaction state to 'loading' to prevent re-clicks during API fetch
                    const previousState = interactionState;
                    interactionState = 'loading'; 
                    
                    const fetchedWords = await fetchEvocativeWord();
                    
                    // Filter out already used words
                    wordCache = fetchedWords.filter(word => !usedWordsSet.has(word.toLowerCase()));
                    
                    // If all fetched words were already used, try fetching again (or just proceed with the current batch to avoid infinite loop)
                    if (wordCache.length === 0 && fetchedWords.length > 0) {
                        wordCache = fetchedWords; 
                    }
                    
                    // Hide loading indicator and restore state if successful
                    loadingElement.classList.add('hidden');
                    interactionState = previousState; 
                    
                    // Reset counter when cache is refilled (a new session of 5 words begins)
                    wordGenerationCount = 0; 
                } catch (error) {
                    console.error("Failed to generate word list:", error);
                    // On failure, revert state and hide loading bar
                    loadingElement.classList.add('hidden');
                    interactionState = 'vortex';
                    return;
                }
            }
            
            // 2. Select a word from the cache, respecting the 'Mother' exclusion rule
            let selectionPool = [...wordCache]; // Create a mutable copy

            if (wordGenerationCount < 3) {
                // If we are within the first three clicks, filter 'mother' out of the selection pool
                selectionPool = selectionPool.filter(word => word.toLowerCase() !== 'mother');
                
                if (selectionPool.length === 0 && wordCache.length > 0) {
                    console.warn("Forced cache refill to exclude 'mother' from the first three words.");
                    wordCache = [];
                    // Recursive call to try to fetch a new batch immediately
                    return generateAndDisplayWord(); 
                }
            }
            
            const randomIndex = Math.floor(Math.random() * selectionPool.length);
            const generatedWord = selectionPool[randomIndex];
            
            // Find and remove the generatedWord from the original wordCache (important for cache management)
            const originalIndex = wordCache.findIndex(word => word.toLowerCase() === generatedWord.toLowerCase());
            if (originalIndex !== -1) {
                wordCache.splice(originalIndex, 1);
            }
            
            // Add word to the set of used words
            usedWordsSet.add(generatedWord.toLowerCase());

            // Increment the counter only after a word has been successfully selected
            wordGenerationCount++; 
            
            // Capture the starting position for the LERP before entering 'word' state
            for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
                wordStartPositions[i] = positions[i];
            }
            interactionState = 'word';

            if (generatedWord) {
                // Step 1: Get 3D target positions for the word (now includes normalization)
                const { positions: wordPositions, scaleFactor } = getTextParticlePositions(generatedWord);

                // Step 2: Populate the targetPositions buffer
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    if (i < wordPositions.length) {
                        // APPLY DYNAMIC SCALE FACTOR HERE
                        targetPositions[i * 3 + 0] = wordPositions[i][0] * scaleFactor;
                        targetPositions[i * 3 + 1] = wordPositions[i][1] * scaleFactor;
                        // Center the word where the camera is now centered (y=0)
                        targetPositions[i * 3 + 1] = wordPositions[i][1] * scaleFactor + VORTEX_OFFSET_Y; 
                        targetPositions[i * 3 + 2] = (Math.random() - 0.5) * 5; 
                    } else {
                        targetPositions[i * 3 + 0] = 0;
                        targetPositions[i * 3 + 1] = 0;
                        targetPositions[i * 3 + 2] = -1000;
                    }
                }
                wordDisplayTime = 0; // Start the transition timer
            }
        }

        /**
         * Uses a hidden 2D canvas to render text and sample pixel positions from it.
         * Now calculates a scale factor to normalize word size.
         */
        function getTextParticlePositions(text) {
            const canvas = document.getElementById('text-canvas');
            const ctx = canvas.getContext('2d');

            const width = 800;
            const height = 200;
            canvas.width = width;
            canvas.height = height;
            ctx.clearRect(0, 0, width, height);

            ctx.font = 'bold 150px Inter, sans-serif';
            ctx.fillStyle = '#FFFFFF';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text.toUpperCase(), width / 2, height / 2);

            // 1. MEASURE TEXT WIDTH FOR DYNAMIC SCALING
            const textMetrics = ctx.measureText(text.toUpperCase());
            const actualTextWidth = textMetrics.width;

            // 2. Calculate the required scale factor to normalize this word's width
            const BASE_3D_SCALE = 0.15;
            const targetPixelWidth = TARGET_CANVAS_WIDTH; 
            
            const normalizationFactor = targetPixelWidth / actualTextWidth;
            const finalScaleFactor = BASE_3D_SCALE * normalizationFactor;


            // 3. SAMPLE PIXELS
            const imageData = ctx.getImageData(0, 0, width, height).data;
            const pixelPositions = [];
            const step = 4; // Sample density

            for (let y = 0; y < height; y += step) {
                for (let x = 0; x < width; x += step) {
                    const index = (y * width + x) * 4;
                    if (imageData[index + 3] > 128) {
                        const nx = x - (width / 2); // Center X
                        const ny = (height / 2) - y; // Center Y (inverted)
                        pixelPositions.push([nx, ny]);
                    }
                }
            }
            
            while (pixelPositions.length < PARTICLE_COUNT) {
                pixelPositions.push(pixelPositions[Math.floor(Math.random() * pixelPositions.length)]);
            }
            
            // Randomize order for better particle distribution
            for (let i = pixelPositions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [pixelPositions[i], pixelPositions[j]] = [pixelPositions[j], pixelPositions[i]];
            }

            // Return positions AND the calculated scale factor
            return { positions: pixelPositions.slice(0, PARTICLE_COUNT), scaleFactor: finalScaleFactor };
        }

        /**
         * Calls the Gemini API to get a list of evocative words in JSON format.
         */
        async function fetchEvocativeWord() {
            const systemPrompt = "You are a creative poet and philosopher focused on the full spectrum of the human psyche. Generate a list of five single, non-hyphenated English words that are **seven letters long or less**. **Strongly bias the list toward gentle, tender, or humanistic concepts (like 'song', 'memory', 'breeze', 'mother')**. Allow one word to be structural or deeply psychological (like 'Id', 'Shadow', 'Repress', 'Oedipus'). Do not use the word 'trauma'.";
            const userQuery = "Generate five evocative words.";

            // Request JSON structure for easy parsing and reliability
            const generationConfig = {
                responseMimeType: "application/json",
                responseSchema: {
                    type: "OBJECT",
                    properties: {
                        "words": {
                            type: "ARRAY",
                            items: { "type": "STRING" }
                        }
                    }
                }
            };

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                },
                generationConfig: generationConfig
            };

            const callApi = async () => {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error("API call failed with status:", response.status, "Response body:", errorText);
                    throw new Error(`API call failed: ${response.status}`);
                }
                const result = await response.json();
                
                const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!text) {
                    throw new Error("API response did not contain text.");
                }

                // Parse the JSON response
                try {
                    const parsedJson = JSON.parse(text);
                    // Return the array of words
                    if (parsedJson.words && Array.isArray(parsedJson.words) && parsedJson.words.length > 0) {
                        return parsedJson.words;
                    } else {
                        throw new Error("Parsed JSON did not contain a valid 'words' array.");
                    }
                } catch (e) {
                    console.error("Failed to parse word JSON:", e);
                    throw new Error("Failed to parse word JSON response.");
                }
            };

            return withBackoff(callApi);
        }

        // --- Animation Loop (Updated with Smootherstep Easing) ---

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = clock.getDelta();
            const time = clock.getElapsedTime();
            
            // 1. Rotation 
            particles.rotation.x += (rotationTarget.x - particles.rotation.x) * 0.1;
            particles.rotation.y += (rotationTarget.y - particles.rotation.y) * 0.1;
            
            // Determine spin speed based on state
            let currentSpinSpeed = VORTEX_SPIN_SPEED;
            if (interactionState === 'word') {
                currentSpinSpeed = WORD_SPIN_SPEED;
            }

            rotationTarget.y += deltaTime * currentSpinSpeed; 

            // 2. CORE FLOW LOGIC: Always run the flow calculation to handle respawning and movement
            // This updates 'originalPositions' with the *target* flow location.
            updateFlowDataAndTarget(time);

            const activePositions = geometry.attributes.position.array;

            // 3. Determine Final Position based on Interaction State
            if (interactionState === 'vortex' || interactionState === 'loading') {
                // If in vortex or loading state, the active positions are simply the calculated flow targets
                for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
                    activePositions[i] = originalPositions[i];
                }
            } else if (interactionState === 'word') {
                // Transition particles to word shape (Target: targetPositions)
                wordDisplayTime += deltaTime * 1000;
                
                const linearProgress = Math.min(1, wordDisplayTime / WORD_TRANSITION_MS); 
                // Apply a smoother step curve to the progress for organic movement
                const easedProgress = THREE.MathUtils.smootherstep(linearProgress, 0, 1); 

                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const i3 = i * 3;
                    // LERP using the eased progress
                    activePositions[i3 + 0] = THREE.MathUtils.lerp(wordStartPositions[i3 + 0], targetPositions[i3 + 0], easedProgress);
                    activePositions[i3 + 1] = THREE.MathUtils.lerp(wordStartPositions[i3 + 1], targetPositions[i3 + 1], easedProgress);
                    activePositions[i3 + 2] = THREE.MathUtils.lerp(wordStartPositions[i3 + 2], targetPositions[i3 + 2], easedProgress);
                }

                if (wordDisplayTime > WORD_DISPLAY_DURATION) {
                    interactionState = 'returning';
                    wordDisplayTime = 0;
                }

            } else if (interactionState === 'returning') {
                // Transition particles back to flowing vortex shape (Target: originalPositions - which is continuously moving)
                wordDisplayTime += deltaTime * 1000;
                
                const linearProgress = Math.min(1, wordDisplayTime / 2000); 
                // Apply a smoother step curve to the progress for organic movement
                const easedProgress = THREE.MathUtils.smootherstep(linearProgress, 0, 1); 

                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const i3 = i * 3;
                    // LERP from the word's target (targetPositions) back to the dynamic flow target (originalPositions)
                    activePositions[i3 + 0] = THREE.MathUtils.lerp(targetPositions[i3 + 0], originalPositions[i3 + 0], easedProgress);
                    activePositions[i3 + 1] = THREE.MathUtils.lerp(targetPositions[i3 + 1], originalPositions[i3 + 1], easedProgress);
                    activePositions[i3 + 2] = THREE.MathUtils.lerp(targetPositions[i3 + 2], originalPositions[i3 + 2], easedProgress);
                }

                // Correct check for completion
                if (linearProgress >= 1) {
                    interactionState = 'vortex';
                }
            }

            geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }

        // Initialize on window load
        window.onload = function() {
            init();
        };

    </script>
</body>
</html>
